<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a href="https://github.com/moos/wordpos">wordpos (v1.1.2)</a>
</h1>
<h4>wordpos is a set of part-of-speech utilities for Node.js using the WordNet database.</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.wordpos">module wordpos</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.wordpos.wordpos">
            function <span class="apidocSignatureSpan"></span>wordpos
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.wordpos.buffered_reader">
            function <span class="apidocSignatureSpan">wordpos.</span>buffered_reader
            <span class="apidocSignatureSpan">(fileName, settings)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.wordpos.dataFile">
            function <span class="apidocSignatureSpan">wordpos.</span>dataFile
            <span class="apidocSignatureSpan">(dictPath, name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.wordpos.indexFile">
            function <span class="apidocSignatureSpan">wordpos.</span>indexFile
            <span class="apidocSignatureSpan">(dictPath, name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.wordpos.piper">
            function <span class="apidocSignatureSpan">wordpos.</span>piper
            <span class="apidocSignatureSpan">(task, method, args, context, callback)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">wordpos.</span>WNdb</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">wordpos.</span>buffered_reader.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">wordpos.</span>dataFile.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">wordpos.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">wordpos.</span>indexFile.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">wordpos.</span>rand</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">wordpos.</span>stopwords</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">wordpos.</span>wordpos.prototype</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.wordpos.buffered_reader">module wordpos.buffered_reader</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.wordpos.buffered_reader.buffered_reader">
            function <span class="apidocSignatureSpan">wordpos.</span>buffered_reader
            <span class="apidocSignatureSpan">(fileName, settings)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.wordpos.buffered_reader.prototype">module wordpos.buffered_reader.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.wordpos.buffered_reader.prototype._init">
            function <span class="apidocSignatureSpan">wordpos.buffered_reader.prototype.</span>_init
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.wordpos.buffered_reader.prototype._read">
            function <span class="apidocSignatureSpan">wordpos.buffered_reader.prototype.</span>_read
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.wordpos.buffered_reader.prototype._readBytes">
            function <span class="apidocSignatureSpan">wordpos.buffered_reader.prototype.</span>_readBytes
            <span class="apidocSignatureSpan">(bytes, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.wordpos.buffered_reader.prototype.close">
            function <span class="apidocSignatureSpan">wordpos.buffered_reader.prototype.</span>close
            <span class="apidocSignatureSpan">(cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.wordpos.buffered_reader.prototype.constructor">
            function <span class="apidocSignatureSpan">wordpos.buffered_reader.prototype.</span>constructor
            <span class="apidocSignatureSpan">(fileName, settings)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.wordpos.buffered_reader.prototype.interrupt">
            function <span class="apidocSignatureSpan">wordpos.buffered_reader.prototype.</span>interrupt
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.wordpos.buffered_reader.prototype.read">
            function <span class="apidocSignatureSpan">wordpos.buffered_reader.prototype.</span>read
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.wordpos.buffered_reader.prototype.readBytes">
            function <span class="apidocSignatureSpan">wordpos.buffered_reader.prototype.</span>readBytes
            <span class="apidocSignatureSpan">(bytes, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.wordpos.buffered_reader.prototype.seek">
            function <span class="apidocSignatureSpan">wordpos.buffered_reader.prototype.</span>seek
            <span class="apidocSignatureSpan">(offset, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.wordpos.buffered_reader.prototype.skip">
            function <span class="apidocSignatureSpan">wordpos.buffered_reader.prototype.</span>skip
            <span class="apidocSignatureSpan">(bytes, cb)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.wordpos.dataFile">module wordpos.dataFile</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.wordpos.dataFile.dataFile">
            function <span class="apidocSignatureSpan">wordpos.</span>dataFile
            <span class="apidocSignatureSpan">(dictPath, name)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">wordpos.dataFile.</span>LEX_NAMES</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">wordpos.dataFile.</span>MAX_LINE_LENGTH</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.wordpos.dataFile.prototype">module wordpos.dataFile.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.wordpos.dataFile.prototype.lookup">
            function <span class="apidocSignatureSpan">wordpos.dataFile.prototype.</span>lookup
            <span class="apidocSignatureSpan">(offsets, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.wordpos.indexFile">module wordpos.indexFile</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.wordpos.indexFile.indexFile">
            function <span class="apidocSignatureSpan">wordpos.</span>indexFile
            <span class="apidocSignatureSpan">(dictPath, name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.wordpos.indexFile.readIndexBetweenKeys">
            function <span class="apidocSignatureSpan">wordpos.indexFile.</span>readIndexBetweenKeys
            <span class="apidocSignatureSpan">(keyStart, keyEnd, index, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.wordpos.indexFile.prototype">module wordpos.indexFile.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.wordpos.indexFile.prototype.find">
            function <span class="apidocSignatureSpan">wordpos.indexFile.prototype.</span>find
            <span class="apidocSignatureSpan">(search, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.wordpos.indexFile.prototype.lookup">
            function <span class="apidocSignatureSpan">wordpos.indexFile.prototype.</span>lookup
            <span class="apidocSignatureSpan">(word, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.wordpos.piper">module wordpos.piper</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.wordpos.piper.piper">
            function <span class="apidocSignatureSpan">wordpos.</span>piper
            <span class="apidocSignatureSpan">(task, method, args, context, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.wordpos.piper.wrapper">
            function <span class="apidocSignatureSpan">wordpos.piper.</span>wrapper
            <span class="apidocSignatureSpan">(self, task)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.wordpos.rand">module wordpos.rand</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.wordpos.rand.init">
            function <span class="apidocSignatureSpan">wordpos.rand.</span>init
            <span class="apidocSignatureSpan">(wordposProto)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.wordpos.wordpos">module wordpos.wordpos</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.wordpos.wordpos.wordpos">
            function <span class="apidocSignatureSpan">wordpos.</span>wordpos
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">wordpos.wordpos.</span>WNdb</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">wordpos.wordpos.</span>defaults</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">wordpos.wordpos.</span>stopwords</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.wordpos.wordpos.prototype">module wordpos.wordpos.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.wordpos.wordpos.prototype.getAdjectives">
            function <span class="apidocSignatureSpan">wordpos.wordpos.prototype.</span>getAdjectives
            <span class="apidocSignatureSpan">(text, callback, _noprofile)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.wordpos.wordpos.prototype.getAdverbs">
            function <span class="apidocSignatureSpan">wordpos.wordpos.prototype.</span>getAdverbs
            <span class="apidocSignatureSpan">(text, callback, _noprofile)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.wordpos.wordpos.prototype.getFilesFor">
            function <span class="apidocSignatureSpan">wordpos.wordpos.prototype.</span>getFilesFor
            <span class="apidocSignatureSpan">(pos)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.wordpos.wordpos.prototype.getNouns">
            function <span class="apidocSignatureSpan">wordpos.wordpos.prototype.</span>getNouns
            <span class="apidocSignatureSpan">(text, callback, _noprofile)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.wordpos.wordpos.prototype.getPOS">
            function <span class="apidocSignatureSpan">wordpos.wordpos.prototype.</span>getPOS
            <span class="apidocSignatureSpan">(text, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.wordpos.wordpos.prototype.getVerbs">
            function <span class="apidocSignatureSpan">wordpos.wordpos.prototype.</span>getVerbs
            <span class="apidocSignatureSpan">(text, callback, _noprofile)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.wordpos.wordpos.prototype.isAdjective">
            function <span class="apidocSignatureSpan">wordpos.wordpos.prototype.</span>isAdjective
            <span class="apidocSignatureSpan">(word, callback, _noprofile)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.wordpos.wordpos.prototype.isAdverb">
            function <span class="apidocSignatureSpan">wordpos.wordpos.prototype.</span>isAdverb
            <span class="apidocSignatureSpan">(word, callback, _noprofile)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.wordpos.wordpos.prototype.isNoun">
            function <span class="apidocSignatureSpan">wordpos.wordpos.prototype.</span>isNoun
            <span class="apidocSignatureSpan">(word, callback, _noprofile)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.wordpos.wordpos.prototype.isVerb">
            function <span class="apidocSignatureSpan">wordpos.wordpos.prototype.</span>isVerb
            <span class="apidocSignatureSpan">(word, callback, _noprofile)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.wordpos.wordpos.prototype.lookup">
            function <span class="apidocSignatureSpan">wordpos.wordpos.prototype.</span>lookup
            <span class="apidocSignatureSpan">(word, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.wordpos.wordpos.prototype.lookupAdjective">
            function <span class="apidocSignatureSpan">wordpos.wordpos.prototype.</span>lookupAdjective
            <span class="apidocSignatureSpan">(word, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.wordpos.wordpos.prototype.lookupAdverb">
            function <span class="apidocSignatureSpan">wordpos.wordpos.prototype.</span>lookupAdverb
            <span class="apidocSignatureSpan">(word, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.wordpos.wordpos.prototype.lookupNoun">
            function <span class="apidocSignatureSpan">wordpos.wordpos.prototype.</span>lookupNoun
            <span class="apidocSignatureSpan">(word, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.wordpos.wordpos.prototype.lookupVerb">
            function <span class="apidocSignatureSpan">wordpos.wordpos.prototype.</span>lookupVerb
            <span class="apidocSignatureSpan">(word, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.wordpos.wordpos.prototype.parse">
            function <span class="apidocSignatureSpan">wordpos.wordpos.prototype.</span>parse
            <span class="apidocSignatureSpan">(text)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.wordpos.wordpos.prototype.seek">
            function <span class="apidocSignatureSpan">wordpos.wordpos.prototype.</span>seek
            <span class="apidocSignatureSpan">(offset, pos, callback)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.wordpos" id="apidoc.module.wordpos">module wordpos</a></h1>


    <h2>
        <a href="#apidoc.element.wordpos.wordpos" id="apidoc.element.wordpos.wordpos">
        function <span class="apidocSignatureSpan"></span>wordpos
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">wordpos = function (options) {
  var dictPath;

  this.options = _.defaults({}, _.isObject(options) &amp;&amp; options || {}, {
    dictPath: WNdb.path
  }, WordPOS.defaults);

  dictPath = this.options.dictPath;

  this.nounIndex = new IndexFile(dictPath, 'noun');
  this.verbIndex = new IndexFile(dictPath, 'verb');
  this.adjIndex = new IndexFile(dictPath, 'adj');
  this.advIndex = new IndexFile(dictPath, 'adv');

  this.nounData = new DataFile(dictPath, 'noun');
  this.verbData = new DataFile(dictPath, 'verb');
  this.adjData = new DataFile(dictPath, 'adj');
  this.advData = new DataFile(dictPath, 'adv');

  // define randX() functions
  require('./rand').init(this);

  if (_.isArray(this.options.stopwords)) {
    this.options.stopwords = makeStopwordString(this.options.stopwords);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.wordpos.buffered_reader" id="apidoc.element.wordpos.buffered_reader">
        function <span class="apidocSignatureSpan">wordpos.</span>buffered_reader
        <span class="apidocSignatureSpan">(fileName, settings)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">buffered_reader = function (fileName, settings){
  EVENTS.EventEmitter.call (this);

  settings = settings || {};

  if (settings.bufferSize === 0) settings.bufferSize = -1;
  this._settings = {
    bufferSize: settings.bufferSize || BUFFER_SIZE,
    encoding: settings.encoding || null,
    start: settings.start || 0,
    end: settings.end
  };

  if (this._settings.bufferSize &lt; 1) throw new Error (INVALID_BUFFER_SIZE);
  if (this._settings.start &lt; 0) throw new Error (INVALID_START_OFFSET);
  if (this._settings.end &lt; 0) throw new Error (INVALID_END_OFFSET);
  if (this._settings.end &lt; this._settings.start) throw new Error (INVALID_RANGE_OFFSET);

  this._fileName = fileName;
  this._fd = null;
  this._buffer = null;

  this._fileOffset = this._settings.start;
  this._bufferOffset = 0;
  this._dataOffset = 0;
  this._realOffset = this._settings.start;

  this._fileSize = null;
  this._initialized = false;
  this._interrupted = false;
  this._isEOF = false;
  this._noMoreBuffers = false;
  this._needRead = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.wordpos.dataFile" id="apidoc.element.wordpos.dataFile">
        function <span class="apidocSignatureSpan">wordpos.</span>dataFile
        <span class="apidocSignatureSpan">(dictPath, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dataFile = function (dictPath, name) {
  this.dictPath = dictPath;
  this.fileName = 'data.' + name;
  this.filePath = path.join(this.dictPath, this.fileName);

  this.maxLineLength = DataFile.MAX_LINE_LENGTH[ name ];
  this.nominalLineLength = MAX_SINGLE_READ_LENGTH;
  this.refcount = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.wordpos.indexFile" id="apidoc.element.wordpos.indexFile">
        function <span class="apidocSignatureSpan">wordpos.</span>indexFile
        <span class="apidocSignatureSpan">(dictPath, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">indexFile = function (dictPath, name) {
  this.dictPath = dictPath;
  this.fileName = 'index.' + name;
  this.filePath = path.join(this.dictPath, this.fileName);
  initIndex(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.wordpos.piper" id="apidoc.element.wordpos.piper">
        function <span class="apidocSignatureSpan">wordpos.</span>piper
        <span class="apidocSignatureSpan">(task, method, args, context, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function piper(task, method, args, context, callback){
  var readCallbacks = this.callbackQueue,
    memoArgs = _.rest(arguments, 2),
    wrappedCallback;

   //console.log('piper', task, [method]);

  // queue up if already reading file for this task
  if (task in readCallbacks){
    readCallbacks[task].push(memoArgs);
    return;
  }
  readCallbacks[task] = [memoArgs];

  if (!this.fd) {
    //console.log(' ... opening', this.filePath);
    this.fd = fs.openSync(this.filePath, 'r');
  }

  // ref count so we know when to close the main index file
  ++this.refcount;

  wrappedCallback = _.partial(piper.wrapper, this, task);

  // call method -- replace original callback (last arg) with wrapped one
  method.apply(null, [].concat( args, wrappedCallback ));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// prepare the piper
var task = 'find:' + key,
  args = [key, this],
  context = [search, callback]; // last arg MUST be callback

// pay the piper
this.<span class="apidocCodeKeywordSpan">piper</span>(task, readIndexForKey, args, context, collector);

function collector(_key, index, search, callback, buffer){
  var lines = buffer.toString().split('\n'),
    keys = lines.map(function(line){
      return line.substring(0,line.indexOf(' '));
    }),
    ind = _.indexOf(keys, search, /*isSorted*/ true);	// binary search!
...</pre></li>
    </ul>


















</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.wordpos.buffered_reader" id="apidoc.module.wordpos.buffered_reader">module wordpos.buffered_reader</a></h1>


    <h2>
        <a href="#apidoc.element.wordpos.buffered_reader.buffered_reader" id="apidoc.element.wordpos.buffered_reader.buffered_reader">
        function <span class="apidocSignatureSpan">wordpos.</span>buffered_reader
        <span class="apidocSignatureSpan">(fileName, settings)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">buffered_reader = function (fileName, settings){
  EVENTS.EventEmitter.call (this);

  settings = settings || {};

  if (settings.bufferSize === 0) settings.bufferSize = -1;
  this._settings = {
    bufferSize: settings.bufferSize || BUFFER_SIZE,
    encoding: settings.encoding || null,
    start: settings.start || 0,
    end: settings.end
  };

  if (this._settings.bufferSize &lt; 1) throw new Error (INVALID_BUFFER_SIZE);
  if (this._settings.start &lt; 0) throw new Error (INVALID_START_OFFSET);
  if (this._settings.end &lt; 0) throw new Error (INVALID_END_OFFSET);
  if (this._settings.end &lt; this._settings.start) throw new Error (INVALID_RANGE_OFFSET);

  this._fileName = fileName;
  this._fd = null;
  this._buffer = null;

  this._fileOffset = this._settings.start;
  this._bufferOffset = 0;
  this._dataOffset = 0;
  this._realOffset = this._settings.start;

  this._fileSize = null;
  this._initialized = false;
  this._interrupted = false;
  this._isEOF = false;
  this._noMoreBuffers = false;
  this._needRead = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.wordpos.buffered_reader.prototype" id="apidoc.module.wordpos.buffered_reader.prototype">module wordpos.buffered_reader.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.wordpos.buffered_reader.prototype._init" id="apidoc.element.wordpos.buffered_reader.prototype._init">
        function <span class="apidocSignatureSpan">wordpos.buffered_reader.prototype.</span>_init
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_init = function (cb){
  var me = this;
  FS.stat (this._fileName, function (error, stats){
    if (error) return cb (error);
    if (stats.isFile ()){
      if (me._settings.start &gt;= stats.size){
        me._isEOF = true;
        return cb (null);
      }
      if (!me._settings.end &amp;&amp; me._settings.end !== 0){
        me._settings.end = stats.size;
      }
      if (me._settings.end &gt;= stats.size){
        me._settings.end = stats.size - 1;
      }
      me._fileSize = stats.size;
      cb (null);
    }else{
      cb (new Error (NO_FILE_ERROR));
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.wordpos.buffered_reader.prototype._read" id="apidoc.element.wordpos.buffered_reader.prototype._read">
        function <span class="apidocSignatureSpan">wordpos.buffered_reader.prototype.</span>_read
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_read = function (cb){
  var me = this;
  var size = this._settings.bufferSize;
  FS.read (this._fd, this._buffer, 0, size, this._fileOffset, function (error, bytesRead){
    if (error) return cb (error);

    me._fileOffset += bytesRead;
    if (me._fileOffset === me._fileSize){
      me._noMoreBuffers = true;
    }
    if (bytesRead &lt; size){
      me._buffer = me._buffer.slice (0, bytesRead);
    }
    cb (null);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.wordpos.buffered_reader.prototype._readBytes" id="apidoc.element.wordpos.buffered_reader.prototype._readBytes">
        function <span class="apidocSignatureSpan">wordpos.buffered_reader.prototype.</span>_readBytes
        <span class="apidocSignatureSpan">(bytes, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_readBytes = function (bytes, cb){
  if (this._needRead){
    this._needRead = false;
    var me = this;
    this._read (function (error){
      if (error) return cb (error, null, -1);
      me._readBytes (bytes, cb);
    });
    return;
  }

  var fill = function (){
    var endData = bytes - me._dataOffset;
    var endBuffer = me._buffer.length - me._bufferOffset;
    var end = endBuffer &lt;= endData ? endBuffer : endData;

    me._buffer.copy (data, me._dataOffset, me._bufferOffset, me._bufferOffset + end);
    me._bufferOffset += end;
    me._realOffset += end;

    if (me._bufferOffset === me._buffer.length){
      me._bufferOffset = 0;
      me._needRead = true;
    }
    me._dataOffset += end;

    if (me._dataOffset === bytes){
      me._dataOffset = 0;
      me._isEOF = me._noMoreBuffers;
      cb (null, data, bytes);
    }else{
      if (me._noMoreBuffers){
        me._isEOF = true;
        end = me._dataOffset;
        me._dataOffset = 0;
        cb (null, data.slice (0, end), end);
      }else{
        me._needRead = false;
        me._read (function (error){
          if (error) return cb (error, null, -1);

          fill ();
        });
      }
    }
  };

  var me = this;

  var max = me._settings.end - me._realOffset + 1;
  bytes = max &lt; bytes ? max : bytes;
  if (bytes === 0) return cb (null, null, 0);

  var data = new Buffer (bytes);
  var len = me._buffer.length;

  if (bytes &lt;= len){
    var end = me._bufferOffset + bytes;

    if (end &lt;= len){
      me._buffer.copy (data, 0, me._bufferOffset, end);
      me._bufferOffset = end;
      me._realOffset += bytes;
      cb (null, data, bytes);
    }else{
      var last = len - me._bufferOffset;
      me._realOffset += last;

      if (last !== 0){
        me._buffer.copy (data, 0, me._bufferOffset, me._bufferOffset + last);
      }
      if (me._noMoreBuffers){
        me._isEOF = true;
        return cb (null, data.slice (0, last), last);
      }

      me._read (function (error){
        if (error) return cb (error, null, -1);

        len = me._buffer.length;
        var remaining = bytes - last;
        if (len &lt;= remaining){
          me._realOffset += len;
          me._isEOF = true;
          me._buffer.copy (data, last, 0, len);
          var lastChunk = last + len;
          cb (null, data.slice (0, lastChunk), lastChunk);
        }else{
          me._realOffset += remaining;
          me._bufferOffset = remaining;
          me._buffer.copy (data, last, 0, me._bufferOffset);
          cb (null, data, bytes);
        }
      });
    }
  }else{
    fill ();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.wordpos.buffered_reader.prototype.close" id="apidoc.element.wordpos.buffered_reader.prototype.close">
        function <span class="apidocSignatureSpan">wordpos.buffered_reader.prototype.</span>close
        <span class="apidocSignatureSpan">(cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">close = function (cb){
  if (cb) cb = cb.bind (this);
  if (!this._fd){
    if (cb) cb (null);
    return;
  }

  var me = this;
  FS.close (this._fd, function (error){
    me._fd = null;
    me._buffer = null;
    if (cb) cb (error);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.wordpos.buffered_reader.prototype.constructor" id="apidoc.element.wordpos.buffered_reader.prototype.constructor">
        function <span class="apidocSignatureSpan">wordpos.buffered_reader.prototype.</span>constructor
        <span class="apidocSignatureSpan">(fileName, settings)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">constructor = function (fileName, settings){
  EVENTS.EventEmitter.call (this);

  settings = settings || {};

  if (settings.bufferSize === 0) settings.bufferSize = -1;
  this._settings = {
    bufferSize: settings.bufferSize || BUFFER_SIZE,
    encoding: settings.encoding || null,
    start: settings.start || 0,
    end: settings.end
  };

  if (this._settings.bufferSize &lt; 1) throw new Error (INVALID_BUFFER_SIZE);
  if (this._settings.start &lt; 0) throw new Error (INVALID_START_OFFSET);
  if (this._settings.end &lt; 0) throw new Error (INVALID_END_OFFSET);
  if (this._settings.end &lt; this._settings.start) throw new Error (INVALID_RANGE_OFFSET);

  this._fileName = fileName;
  this._fd = null;
  this._buffer = null;

  this._fileOffset = this._settings.start;
  this._bufferOffset = 0;
  this._dataOffset = 0;
  this._realOffset = this._settings.start;

  this._fileSize = null;
  this._initialized = false;
  this._interrupted = false;
  this._isEOF = false;
  this._noMoreBuffers = false;
  this._needRead = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.wordpos.buffered_reader.prototype.interrupt" id="apidoc.element.wordpos.buffered_reader.prototype.interrupt">
        function <span class="apidocSignatureSpan">wordpos.buffered_reader.prototype.</span>interrupt
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">interrupt = function (){
  this._interrupted = true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    .on ("error", function (error){
console.log ("error: %s", indexFile, error);
    })
    .on ("line", function (line, offset){
// skip license info
if (line[0] == ' ') return;

// if (++i &gt; 225) return this.<span class="apidocCodeKeywordSpan">interrupt</span>();
var key = line.substring(0, Math.min(line.indexOf(' '), KEY_LENGTH));
if (firstKey === null) firstKey = key;

if (key in buckets) {
  ++buckets[key];
  return;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.wordpos.buffered_reader.prototype.read" id="apidoc.element.wordpos.buffered_reader.prototype.read">
        function <span class="apidocSignatureSpan">wordpos.buffered_reader.prototype.</span>read
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">read = function (){
  var stream = FS.createReadStream (this._fileName, this._settings);

  // node version change: stream.encoding no longer exposed
  stream.encoding = this._settings.encoding;

  var lastChunk;
  var buffer;
  var me = this;
  var lineOffset = 0,
    lineCount = 0,
    byteOffset = 0;

  var onChar = this.listeners ("character").length !== 0,
    onLine = this.listeners ("line").length !== 0,
    onByte = this.listeners ("byte").length !== 0,
    loop = onChar || onLine || onByte;

  stream.on ("data", function (data){
    buffer = data;
    var offset = 0;
    var chunk;
    var character;
    var len = data.length;

    if (loop){
      for (var i=0; i&lt;len; i++){
        if (me._interrupted) break;

        character = data[i];
        if (stream.encoding){
          onChar &amp;&amp; me.emit ("character", character === "\r" ? "\n" : character, byteOffset + i);
        }else{
          onByte &amp;&amp; me.emit ("byte", character, byteOffset + i);
          continue;
        }

        if (!onLine) continue;
        if (character === "\n" || character === "\r"){
          chunk = data.slice (offset, i);

          if (lastChunk){
            chunk = lastChunk.concat (chunk);
          }

          if (i + 1 !== len &amp;&amp; character === "\r" &amp;&amp; data[i + 1] === "\n"){
            i++;
          }

          me.emit ("line", chunk, lineOffset + offset, ++lineCount);
          offset = i + 1;
          if (lastChunk){
              lineOffset += lastChunk.length;
              lastChunk = null;
            }
        }
      }

      if (stream.encoding &amp;&amp; offset !== len){
        var s = offset === 0 ? data : data.slice (offset);
        lastChunk = lastChunk ? lastChunk.concat (s) : s;
      }
      lineOffset += offset;
    }

    me.emit ("buffer", data, byteOffset);
    if (me._interrupted){
      me._interrupted = false;
      stream.destroy ();
      me.emit ("end");
    }
    byteOffset += len;

  });

  stream.on ("end", function (){
    me._interrupted = false;
    if (loop &amp;&amp; lastChunk){
      me.emit ("line", lastChunk);
    }
    me.emit ("end");
  });

  stream.on ("error", function (error){
    me._interrupted = false;
    me.emit ("error", error);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    //console.log('  read %d bytes at &lt;%d&gt;', count, location);
    callback(null, lineDataToJSON(str, location));
  });

  function readChunk(pos, cb) {
    var nonDataErr = new Error('no data at offset ' + pos);

    fs.<span class="apidocCodeKeywordSpan">read</span>(file.fd, buffer, 0, len, pos, function (err, count) {
if (!count) return cb(nonDataErr, count);

str += buffer.toString('ascii');
var eol = str.indexOf('\n');
//console.log('  -- read %d bytes at &lt;%d&gt;', count, pos, eol);
if (count &amp;&amp; eol === -1 &amp;&amp; len &lt; file.maxLineLength) {
  // continue reading
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.wordpos.buffered_reader.prototype.readBytes" id="apidoc.element.wordpos.buffered_reader.prototype.readBytes">
        function <span class="apidocSignatureSpan">wordpos.buffered_reader.prototype.</span>readBytes
        <span class="apidocSignatureSpan">(bytes, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readBytes = function (bytes, cb){
  cb = cb.bind (this);
  if (bytes &lt; 1 || this._isEOF) return cb (null, null, 0);

  var open = function (){
    if (me._isEOF) return cb (null, null, 0);
    FS.open (me._fileName, "r", function (error, fd){
      if (error) return cb (error, null, -1);

      me._fd = fd;
      me._buffer = new Buffer (me._settings.bufferSize);
      me._read (function (error){
        if (error) return cb (error, null, -1);
        me._readBytes (bytes, cb);
      });
    });
  };

  var me = this;
  if (!this._initialized){
    this._init (function (error){
      if (error) return cb (error, null);
      me._initialized = true;
      open ();
    });
  }else{
    if (!this._fd) return open ();
    this._readBytes (bytes, cb);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.wordpos.buffered_reader.prototype.seek" id="apidoc.element.wordpos.buffered_reader.prototype.seek">
        function <span class="apidocSignatureSpan">wordpos.buffered_reader.prototype.</span>seek
        <span class="apidocSignatureSpan">(offset, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">seek = function (offset, cb){
  cb = cb.bind (this);
  if (offset &lt; 0) return cb (new Error (INVALID_SEEK_OFFSET));

  var seek = function (){
    offset += me._settings.start;
    if (offset &gt;= me._settings.end + 1){
      me._isEOF = true;
    }else{
      me._isEOF = false;
      var start = me._fileOffset - (me._buffer ? me._buffer.length : 0);
      if (offset &gt;= start &amp;&amp; offset &lt; me._fileOffset){
        me._bufferOffset = offset - start;
        me._realOffset = offset;
      }else{
        me._needRead = me._fd ? true : false;
        me._noMoreBuffers = false;
        me._fileOffset = offset;
        me._bufferOffset = 0;
        me._realOffset = offset;
      }
    }
    cb (null);
  };

  var me = this;
  if (!this._initialized){
    this._init (function (error){
      if (error) return cb (error, null);
      me._initialized = true;
      seek ();
    });
  }else{
    seek ();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...


#### seek(offset, pos, callback)
Version 1.1 introduces the seek method to lookup a record directly from the synsetOffset for a given POS.  Unlike other methods,
callback (if provided) receives `(err, result)` arguments.

Examples:
```js
wordpos.<span class="apidocCodeKeywordSpan">seek</span>(1285602, 'a').then(console.log)
// same result as wordpos.lookupAdjective('awesome', console.log);
```

#### rand(options, callback)
#### randNoun(options, callback)
#### randVerb(options, callback)
#### randAdjective(options, callback)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.wordpos.buffered_reader.prototype.skip" id="apidoc.element.wordpos.buffered_reader.prototype.skip">
        function <span class="apidocSignatureSpan">wordpos.buffered_reader.prototype.</span>skip
        <span class="apidocSignatureSpan">(bytes, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">skip = function (bytes, cb){
  cb = cb.bind (this);
  if (bytes &lt; 1 || this._isEOF) return cb (null, 0);

  var skip = function (){
    var remaining = me._settings.end - me._realOffset + 1;
    bytes = bytes &lt;= remaining ? bytes : remaining;
    me.seek (me._realOffset - me._settings.start + bytes, function (){
      cb (null, bytes);
    });
  };

  var me = this;
  if (!this._initialized){
    this._init (function (error){
      if (error) return cb (error, null);
      me._initialized = true;
      skip ();
    });
  }else{
    skip ();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.wordpos.dataFile" id="apidoc.module.wordpos.dataFile">module wordpos.dataFile</a></h1>


    <h2>
        <a href="#apidoc.element.wordpos.dataFile.dataFile" id="apidoc.element.wordpos.dataFile.dataFile">
        function <span class="apidocSignatureSpan">wordpos.</span>dataFile
        <span class="apidocSignatureSpan">(dictPath, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dataFile = function (dictPath, name) {
  this.dictPath = dictPath;
  this.fileName = 'data.' + name;
  this.filePath = path.join(this.dictPath, this.fileName);

  this.maxLineLength = DataFile.MAX_LINE_LENGTH[ name ];
  this.nominalLineLength = MAX_SINGLE_READ_LENGTH;
  this.refcount = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.wordpos.dataFile.prototype" id="apidoc.module.wordpos.dataFile.prototype">module wordpos.dataFile.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.wordpos.dataFile.prototype.lookup" id="apidoc.element.wordpos.dataFile.prototype.lookup">
        function <span class="apidocSignatureSpan">wordpos.dataFile.prototype.</span>lookup
        <span class="apidocSignatureSpan">(offsets, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function lookup(offsets, callback) {
  var results = [],
    self = this,
    single = !_.isArray(offsets);

  if (single) offsets = [offsets];
  return new Promise(function(resolve, reject) {
    offsets
      .map(function (offset) {
        return _.partial(readLocation.bind(self), offset);
      })
      .map(promisifyInto(results))
      .reduce(serialize, openFile())
      .then(done)
      .catch(done);

    function done(lastResult) {
      closeFile();
      if (lastResult instanceof Error) {
        callback &amp;&amp; callback(lastResult, single ? {} :[]);
        reject(lastResult);
      } else {
        if (single) results = results[0];
        callback &amp;&amp; callback(null, results);
        resolve(results);
      }
    }
  });

  function serialize(prev, next) {
    return prev.then(next);
  }

  function openFile() {
    if (!self.fd) {
      // console.log(' ... opening', self.filePath);
      self.fd = fs.openSync(self.filePath, 'r');
    }
    // ref count so we know when to close the main index file
    ++self.refcount;
    return Promise.resolve();
  }

  function closeFile() {
    if (--self.refcount === 0) {
      // console.log(' ... closing', self.filePath);
      fs.closeSync(self.fd);
      self.fd = null;
    }
    return Promise.resolve();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}


function lookup(next){
  var count = nwords;
  found = 0;
  parsedText.forEach(function(word) {
    wordpos.<span class="apidocCodeKeywordSpan">lookup</span>(word, function (res) {
      res.length &amp;&amp; ++found;
      if (--count === 0) next();
    });
  });
}

function lookupNoun(next){
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.wordpos.indexFile" id="apidoc.module.wordpos.indexFile">module wordpos.indexFile</a></h1>


    <h2>
        <a href="#apidoc.element.wordpos.indexFile.indexFile" id="apidoc.element.wordpos.indexFile.indexFile">
        function <span class="apidocSignatureSpan">wordpos.</span>indexFile
        <span class="apidocSignatureSpan">(dictPath, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">indexFile = function (dictPath, name) {
  this.dictPath = dictPath;
  this.fileName = 'index.' + name;
  this.filePath = path.join(this.dictPath, this.fileName);
  initIndex(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.wordpos.indexFile.readIndexBetweenKeys" id="apidoc.element.wordpos.indexFile.readIndexBetweenKeys">
        function <span class="apidocSignatureSpan">wordpos.indexFile.</span>readIndexBetweenKeys
        <span class="apidocSignatureSpan">(keyStart, keyEnd, index, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function readIndexBetweenKeys(keyStart, keyEnd, index, callback) {
  var data = index.fastIndex,
    offset = data.offsets[keyStart][0],
    end = keyEnd || keyStart,
    nextKey = data.offsets[end][1],
    nextOffset = data.offsets[nextKey][0],
    len = nextOffset - offset - 1,
    buffer = new Buffer(len);

  //console.log('### readIndexBetweenKeys', keyStart, keyEnd, nextKey, len)
  fs.read(index.fd, buffer, 0, len, offset, function(err, count){
     if (err) return console.log(err);
     // console.log('  read %d bytes for &lt;%s&gt;', count, keyStart);
     callback(buffer);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.wordpos.indexFile.prototype" id="apidoc.module.wordpos.indexFile.prototype">module wordpos.indexFile.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.wordpos.indexFile.prototype.find" id="apidoc.element.wordpos.indexFile.prototype.find">
        function <span class="apidocSignatureSpan">wordpos.indexFile.prototype.</span>find
        <span class="apidocSignatureSpan">(search, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function find(search, callback) {
  var self = this,
    data = this.fastIndex,
    readCallbacks = this.callbackQueue,
    miss = {status: 'miss'};

  var key = search.slice(0, KEY_LENGTH);
  if (!(key in data.offsets)) return process.nextTick(function(){ callback(miss) });

  // prepare the piper
  var task = 'find:' + key,
    args = [key, this],
    context = [search, callback]; // last arg MUST be callback

  // pay the piper
  this.piper(task, readIndexForKey, args, context, collector);

  function collector(_key, index, search, callback, buffer){
    var lines = buffer.toString().split('\n'),
      keys = lines.map(function(line){
        return line.substring(0,line.indexOf(' '));
      }),
      ind = _.indexOf(keys, search, /*isSorted*/ true);	// binary search!

    //console.log(' %s is %d', search, ind);
    if (ind === -1) return callback(miss);

    var tokens = lines[ind].split(/\s+/),
      key = tokens[0],
      result = {status: 'hit', key: key, 'line': lines[ind], tokens: tokens};

    callback(result);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  });
}
}

/**
 * main lookup function
 *
 * @param offsets {array} - array of offsets to lookup (obtained from index.<span class="apidocCodeKeywordSpan">find</span>())
 * @param callback{function} (optional) - callback function
 * @returns {Promise}
 */
function lookup(offsets, callback) {
var results = [],
  self = this,
  single = !_.isArray(offsets);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.wordpos.indexFile.prototype.lookup" id="apidoc.element.wordpos.indexFile.prototype.lookup">
        function <span class="apidocSignatureSpan">wordpos.indexFile.prototype.</span>lookup
        <span class="apidocSignatureSpan">(word, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function lookup(word, callback) {
  var self = this;

  return new Promise(function(resolve, reject){
    self.find(word, function (record) {
      var indexRecord = null,
        i;

      if (record.status == 'hit') {
        var ptrs = [], offsets = [];

        for (i = 0; i &lt; parseInt(record.tokens[3]); i++)
          ptrs.push(record.tokens[i]);

        for (i = 0; i &lt; parseInt(record.tokens[2]); i++)
          offsets.push(parseInt(record.tokens[ptrs.length + 6 + i], 10));

        indexRecord = {
          lemma       : record.tokens[0],
          pos         : record.tokens[1],
          ptrSymbol   : ptrs,
          senseCnt    : parseInt(record.tokens[ptrs.length + 4], 10),
          tagsenseCnt : parseInt(record.tokens[ptrs.length + 5], 10),
          synsetOffset: offsets
        };
      }

      callback &amp;&amp; callback(indexRecord);
      resolve(indexRecord);
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}


function lookup(next){
  var count = nwords;
  found = 0;
  parsedText.forEach(function(word) {
    wordpos.<span class="apidocCodeKeywordSpan">lookup</span>(word, function (res) {
      res.length &amp;&amp; ++found;
      if (--count === 0) next();
    });
  });
}

function lookupNoun(next){
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.wordpos.piper" id="apidoc.module.wordpos.piper">module wordpos.piper</a></h1>


    <h2>
        <a href="#apidoc.element.wordpos.piper.piper" id="apidoc.element.wordpos.piper.piper">
        function <span class="apidocSignatureSpan">wordpos.</span>piper
        <span class="apidocSignatureSpan">(task, method, args, context, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function piper(task, method, args, context, callback){
  var readCallbacks = this.callbackQueue,
    memoArgs = _.rest(arguments, 2),
    wrappedCallback;

   //console.log('piper', task, [method]);

  // queue up if already reading file for this task
  if (task in readCallbacks){
    readCallbacks[task].push(memoArgs);
    return;
  }
  readCallbacks[task] = [memoArgs];

  if (!this.fd) {
    //console.log(' ... opening', this.filePath);
    this.fd = fs.openSync(this.filePath, 'r');
  }

  // ref count so we know when to close the main index file
  ++this.refcount;

  wrappedCallback = _.partial(piper.wrapper, this, task);

  // call method -- replace original callback (last arg) with wrapped one
  method.apply(null, [].concat( args, wrappedCallback ));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// prepare the piper
var task = 'find:' + key,
  args = [key, this],
  context = [search, callback]; // last arg MUST be callback

// pay the piper
this.<span class="apidocCodeKeywordSpan">piper</span>(task, readIndexForKey, args, context, collector);

function collector(_key, index, search, callback, buffer){
  var lines = buffer.toString().split('\n'),
    keys = lines.map(function(line){
      return line.substring(0,line.indexOf(' '));
    }),
    ind = _.indexOf(keys, search, /*isSorted*/ true);	// binary search!
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.wordpos.piper.wrapper" id="apidoc.element.wordpos.piper.wrapper">
        function <span class="apidocSignatureSpan">wordpos.piper.</span>wrapper
        <span class="apidocSignatureSpan">(self, task)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">wrapper = function (self, task){
  var readCallbacks = self.callbackQueue,
    result = _.rest(arguments, 2),
    callback, args;

  // live access callbacks cache in case nested cb's
  // add to the array.
  while (args = readCallbacks[task].shift()) {
    callback = args.pop(); // last arg MUST be callback

//    console.log('&gt;&gt;&gt;&gt; pper wrapper', self.fastIndex.name, task, result.toString())
    callback.apply(null, [].concat(_.flatten(args, /*shallow*/true), result));
  }

  // now done - delete cb cache
  delete readCallbacks[task];

  if (--self.refcount === 0) {
    //console.log(' ... closing', self.filePath);
    fs.closeSync(self.fd);
    self.fd = null;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.wordpos.rand" id="apidoc.module.wordpos.rand">module wordpos.rand</a></h1>


    <h2>
        <a href="#apidoc.element.wordpos.rand.init" id="apidoc.element.wordpos.rand.init">
        function <span class="apidocSignatureSpan">wordpos.rand.</span>init
        <span class="apidocSignatureSpan">(wordposProto)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">init = function (wordposProto) {
  wordposProto.nounIndex.rand = randomify(wordposProto.nounIndex);
  wordposProto.verbIndex.rand = randomify(wordposProto.verbIndex);
  wordposProto.adjIndex.rand = randomify(wordposProto.adjIndex);
  wordposProto.advIndex.rand = randomify(wordposProto.advIndex);

  /**
   * define rand()
   */
  wordposProto.rand = randAll;

  /**
   * define randX()
   */
  wordposProto.randAdjective = makeRandX('a');
  wordposProto.randAdverb = makeRandX('r');
  wordposProto.randNoun = makeRandX('n');
  wordposProto.randVerb = makeRandX('v');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.wordpos.wordpos" id="apidoc.module.wordpos.wordpos">module wordpos.wordpos</a></h1>


    <h2>
        <a href="#apidoc.element.wordpos.wordpos.wordpos" id="apidoc.element.wordpos.wordpos.wordpos">
        function <span class="apidocSignatureSpan">wordpos.</span>wordpos
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">wordpos = function (options) {
  var dictPath;

  this.options = _.defaults({}, _.isObject(options) &amp;&amp; options || {}, {
    dictPath: WNdb.path
  }, WordPOS.defaults);

  dictPath = this.options.dictPath;

  this.nounIndex = new IndexFile(dictPath, 'noun');
  this.verbIndex = new IndexFile(dictPath, 'verb');
  this.adjIndex = new IndexFile(dictPath, 'adj');
  this.advIndex = new IndexFile(dictPath, 'adv');

  this.nounData = new DataFile(dictPath, 'noun');
  this.verbData = new DataFile(dictPath, 'verb');
  this.adjData = new DataFile(dictPath, 'adj');
  this.advData = new DataFile(dictPath, 'adv');

  // define randX() functions
  require('./rand').init(this);

  if (_.isArray(this.options.stopwords)) {
    this.options.stopwords = makeStopwordString(this.options.stopwords);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.wordpos.wordpos.prototype" id="apidoc.module.wordpos.wordpos.prototype">module wordpos.wordpos.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.wordpos.wordpos.prototype.getAdjectives" id="apidoc.element.wordpos.wordpos.prototype.getAdjectives">
        function <span class="apidocSignatureSpan">wordpos.wordpos.prototype.</span>getAdjectives
        <span class="apidocSignatureSpan">(text, callback, _noprofile)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getAdjectives = function (text, callback, _noprofile) {
  var profile = this.options.profile &amp;&amp; !_noprofile,
    start = profile &amp;&amp; new Date(),
    words = this.parse(text),
    results = [],
    self = this;

  //if (!n) return (process.nextTick(done),0);
  return Promise
    .all(words.map(exec))
    .then(done);

  function exec(word) {
    return self[isFn]
      .call(self, word, null, /*_noprofile*/ true)
      .then(function collect(result) {
        result &amp;&amp; results.push(word);
      });
  }

  function done(){
    var args = [results];
    profile &amp;&amp; args.push(new Date() - start);
    nextTick(callback, args);
    return results;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
## Quick usage

Node.js:
```js
var WordPOS = require('wordpos'),
    wordpos = new WordPOS();

wordpos.<span class="apidocCodeKeywordSpan">getAdjectives</span>('The angry bear chased the frightened little squirrel.'
;, function(result){
    console.log(result);
});
// [ 'little', 'angry', 'frightened' ]

wordpos.isAdjective('awesome', function(result){
    console.log(result);
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.wordpos.wordpos.prototype.getAdverbs" id="apidoc.element.wordpos.wordpos.prototype.getAdverbs">
        function <span class="apidocSignatureSpan">wordpos.wordpos.prototype.</span>getAdverbs
        <span class="apidocSignatureSpan">(text, callback, _noprofile)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getAdverbs = function (text, callback, _noprofile) {
  var profile = this.options.profile &amp;&amp; !_noprofile,
    start = profile &amp;&amp; new Date(),
    words = this.parse(text),
    results = [],
    self = this;

  //if (!n) return (process.nextTick(done),0);
  return Promise
    .all(words.map(exec))
    .then(done);

  function exec(word) {
    return self[isFn]
      .call(self, word, null, /*_noprofile*/ true)
      .then(function collect(result) {
        result &amp;&amp; results.push(word);
      });
  }

  function done(){
    var args = [results];
    profile &amp;&amp; args.push(new Date() - start);
    nextTick(callback, args);
    return results;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  wordpos.getAdjectives(text, function(res){
    pos = {adjectives: res};
    next();
  });
}

function getAdverbs(next){
  wordpos.<span class="apidocCodeKeywordSpan">getAdverbs</span>(text, function(res){
    pos = {adverbs: res};
    next();
  });
}


function lookup(next){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.wordpos.wordpos.prototype.getFilesFor" id="apidoc.element.wordpos.wordpos.prototype.getFilesFor">
        function <span class="apidocSignatureSpan">wordpos.wordpos.prototype.</span>getFilesFor
        <span class="apidocSignatureSpan">(pos)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getFilesFor = function (pos) {
  switch(pos) {
    case 'n':
      return {index: this.nounIndex, data: this.nounData};
    case 'v':
      return {index: this.verbIndex, data: this.verbData};
    case 'a': case 's':
    return {index: this.adjIndex, data: this.adjData};
    case 'r':
      return {index: this.advIndex, data: this.advData};
  }
  return {};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 */
function makeRandX(pos){
  return function(opts, callback, _noprofile) {
// disable profiling when isX() used internally
var profile = this.options.profile &amp;&amp; !_noprofile,
  start = profile &amp;&amp; new Date(),
  args = [],
  index = this.<span class="apidocCodeKeywordSpan">getFilesFor</span>(pos).index,
  startsWith = opts &amp;&amp; opts.startsWith || '',
  count = opts &amp;&amp; opts.count || 1;

if (typeof opts === 'function') {
  callback = opts;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.wordpos.wordpos.prototype.getNouns" id="apidoc.element.wordpos.wordpos.prototype.getNouns">
        function <span class="apidocSignatureSpan">wordpos.wordpos.prototype.</span>getNouns
        <span class="apidocSignatureSpan">(text, callback, _noprofile)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getNouns = function (text, callback, _noprofile) {
  var profile = this.options.profile &amp;&amp; !_noprofile,
    start = profile &amp;&amp; new Date(),
    words = this.parse(text),
    results = [],
    self = this;

  //if (!n) return (process.nextTick(done),0);
  return Promise
    .all(words.map(exec))
    .then(done);

  function exec(word) {
    return self[isFn]
      .call(self, word, null, /*_noprofile*/ true)
      .then(function collect(result) {
        result &amp;&amp; results.push(word);
      });
  }

  function done(){
    var args = [results];
    profile &amp;&amp; args.push(new Date() - start);
    nextTick(callback, args);
    return results;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
If `text` is an *array*, all words are looked-up -- no deduplication, stopword filtering or tokenization is applied.

getX() functions return a Promise.

Example:

```js
wordpos.<span class="apidocCodeKeywordSpan">getNouns</span>('The angry bear chased the frightened little squirrel.', console
.log)
// [ 'bear', 'squirrel', 'little', 'chased' ]

wordpos.getPOS('The angry bear chased the frightened little squirrel.', console.log)
// output:
{
  nouns: [ 'bear', 'squirrel', 'little', 'chased' ],
  verbs: [ 'bear' ],
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.wordpos.wordpos.prototype.getPOS" id="apidoc.element.wordpos.wordpos.prototype.getPOS">
        function <span class="apidocSignatureSpan">wordpos.wordpos.prototype.</span>getPOS
        <span class="apidocSignatureSpan">(text, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getPOS = function (text, callback) {
  var self = this,
    data = {nouns:[], verbs:[], adjectives:[], adverbs:[], rest:[]},
    profile = this.options.profile,
    start = profile &amp;&amp; new Date(),
    words = this.parse(text),
    methods = ['getAdverbs', 'getAdjectives', 'getVerbs', 'getNouns'];

  return Promise
    .all(methods.map(exec))
    .then(done)
    .catch(error);

  function exec(method) {
    return self[ method ]
      .call(self, text, null, true)
      .then(function collect(results) {
        // getAdjectives --&gt; adjectives
        var pos = method.replace('get','').toLowerCase();
        data[ pos ] =  results;
      });
  }

  function done() {
    var matches = _(data).chain()
      .values()
      .flatten()
      .uniq()
      .value(),
      args = [data];

    data.rest =  _(words).difference(matches);

    profile &amp;&amp; args.push(new Date() - start);
    nextTick(callback, args);
    return data;
  }

  function error(err) {
    nextTick(callback, []);
    throw err;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
#### getVerbs(text, callback)
#### getAdjectives(text, callback)
#### getAdverbs(text, callback)

Get part-of-speech from `text`.  `callback(results)` receives an array of words for specified POS, or a hash for `getPOS()`:

```
wordpos.<span class="apidocCodeKeywordSpan">getPOS</span>(text, callback) -- callback receives a result object:
{
  nouns:[],       Array of words that are nouns
  verbs:[],       Array of words that are verbs
  adjectives:[],  Array of words that are adjectives
  adverbs:[],     Array of words that are adverbs
  rest:[]         Array of words that are not in dict or could not be categorized as a POS
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.wordpos.wordpos.prototype.getVerbs" id="apidoc.element.wordpos.wordpos.prototype.getVerbs">
        function <span class="apidocSignatureSpan">wordpos.wordpos.prototype.</span>getVerbs
        <span class="apidocSignatureSpan">(text, callback, _noprofile)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getVerbs = function (text, callback, _noprofile) {
  var profile = this.options.profile &amp;&amp; !_noprofile,
    start = profile &amp;&amp; new Date(),
    words = this.parse(text),
    results = [],
    self = this;

  //if (!n) return (process.nextTick(done),0);
  return Promise
    .all(words.map(exec))
    .then(done);

  function exec(word) {
    return self[isFn]
      .call(self, word, null, /*_noprofile*/ true)
      .then(function collect(result) {
        result &amp;&amp; results.push(word);
      });
  }

  function done(){
    var args = [results];
    profile &amp;&amp; args.push(new Date() - start);
    nextTick(callback, args);
    return results;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
wordpos.getNouns(text, function(res){
  pos = {nouns: res};
  next();
});
}

function getVerbs(next){
wordpos.<span class="apidocCodeKeywordSpan">getVerbs</span>(text, function(res){
  pos = {verbs: res};
  next();
});
}

function getAdjectives(next){
wordpos.getAdjectives(text, function(res){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.wordpos.wordpos.prototype.isAdjective" id="apidoc.element.wordpos.wordpos.prototype.isAdjective">
        function <span class="apidocSignatureSpan">wordpos.wordpos.prototype.</span>isAdjective
        <span class="apidocSignatureSpan">(word, callback, _noprofile)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isAdjective = function (word, callback, _noprofile) {
  // disable profiling when isX() used internally
  var profile = this.options.profile &amp;&amp; !_noprofile,
    start = profile &amp;&amp; new Date(),
    args = [],
    index = this.getFilesFor(pos).index;
  word = normalize(word);

  return index
    .lookup(word)
    .then(function(record) {
      var result = !!record;
      args.push(result, word);
      profile &amp;&amp; args.push(new Date() - start);
      nextTick(callback, args);
      return result;
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    wordpos = new WordPOS();

wordpos.getAdjectives('The angry bear chased the frightened little squirrel.', function(result){
    console.log(result);
});
// [ 'little', 'angry', 'frightened' ]

wordpos.<span class="apidocCodeKeywordSpan">isAdjective</span>('awesome', function(result){
    console.log(result);
});
// true 'awesome'
```

Command-line: (see [CLI](bin) for full command list)
```bash
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.wordpos.wordpos.prototype.isAdverb" id="apidoc.element.wordpos.wordpos.prototype.isAdverb">
        function <span class="apidocSignatureSpan">wordpos.wordpos.prototype.</span>isAdverb
        <span class="apidocSignatureSpan">(word, callback, _noprofile)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isAdverb = function (word, callback, _noprofile) {
  // disable profiling when isX() used internally
  var profile = this.options.profile &amp;&amp; !_noprofile,
    start = profile &amp;&amp; new Date(),
    args = [],
    index = this.getFilesFor(pos).index;
  word = normalize(word);

  return index
    .lookup(word)
    .then(function(record) {
      var result = !!record;
      args.push(result, word);
      profile &amp;&amp; args.push(new Date() - start);
      nextTick(callback, args);
      return result;
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

wordpos.isNoun('fish', console.log);
// true 'fish'

wordpos.isAdjective('fishy', console.log);
// true 'fishy'

wordpos.<span class="apidocCodeKeywordSpan">isAdverb</span>('fishly', console.log);
// false 'fishly'
```

#### lookup(word, callback)
#### lookupNoun(word, callback)
#### lookupVerb(word, callback)
#### lookupAdjective(word, callback)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.wordpos.wordpos.prototype.isNoun" id="apidoc.element.wordpos.wordpos.prototype.isNoun">
        function <span class="apidocSignatureSpan">wordpos.wordpos.prototype.</span>isNoun
        <span class="apidocSignatureSpan">(word, callback, _noprofile)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isNoun = function (word, callback, _noprofile) {
  // disable profiling when isX() used internally
  var profile = this.options.profile &amp;&amp; !_noprofile,
    start = profile &amp;&amp; new Date(),
    args = [],
    index = this.getFilesFor(pos).index;
  word = normalize(word);

  return index
    .lookup(word)
    .then(function(record) {
      var result = !!record;
      args.push(result, word);
      profile &amp;&amp; args.push(new Date() - start);
      nextTick(callback, args);
      return result;
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Examples:

```js
wordpos.isVerb('fish', console.log);
// true 'fish'

wordpos.<span class="apidocCodeKeywordSpan">isNoun</span>('fish', console.log);
// true 'fish'

wordpos.isAdjective('fishy', console.log);
// true 'fishy'

wordpos.isAdverb('fishly', console.log);
// false 'fishly'
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.wordpos.wordpos.prototype.isVerb" id="apidoc.element.wordpos.wordpos.prototype.isVerb">
        function <span class="apidocSignatureSpan">wordpos.wordpos.prototype.</span>isVerb
        <span class="apidocSignatureSpan">(word, callback, _noprofile)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isVerb = function (word, callback, _noprofile) {
  // disable profiling when isX() used internally
  var profile = this.options.profile &amp;&amp; !_noprofile,
    start = profile &amp;&amp; new Date(),
    args = [],
    index = this.getFilesFor(pos).index;
  word = normalize(word);

  return index
    .lookup(word)
    .then(function(record) {
      var result = !!record;
      args.push(result, word);
      profile &amp;&amp; args.push(new Date() - start);
      nextTick(callback, args);
      return result;
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
#### isAdverb(word, callback)

Determine if `word` is a particular POS.  `callback(result, word)` receives true/false as first argument and the looked-up word
as the second argument. The resolved Promise receives true/false.

Examples:

```js
wordpos.<span class="apidocCodeKeywordSpan">isVerb</span>('fish', console.log);
// true 'fish'

wordpos.isNoun('fish', console.log);
// true 'fish'

wordpos.isAdjective('fishy', console.log);
// true 'fishy'
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.wordpos.wordpos.prototype.lookup" id="apidoc.element.wordpos.wordpos.prototype.lookup">
        function <span class="apidocSignatureSpan">wordpos.wordpos.prototype.</span>lookup
        <span class="apidocSignatureSpan">(word, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lookup = function (word, callback) {
  var self = this,
    results = [],
    profile = this.options.profile,
    start = profile &amp;&amp; new Date(),
    methods = ['lookupAdverb', 'lookupAdjective', 'lookupVerb', 'lookupNoun'];

  return Promise
    .all(methods.map(exec))
    .then(done)
    .catch(error);

  function exec(method) {
    return self[ method ]
      .call(self, word)
      .then(function collect(result){
        results = results.concat(result);
      });
  }

  function done() {
    var args = [results, word];
    profile &amp;&amp; args.push(new Date() - start);
    nextTick(callback, args);
    return results;
  }

  function error(err) {
    nextTick(callback, [[], word]);
    throw err;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}


function lookup(next){
  var count = nwords;
  found = 0;
  parsedText.forEach(function(word) {
    wordpos.<span class="apidocCodeKeywordSpan">lookup</span>(word, function (res) {
      res.length &amp;&amp; ++found;
      if (--count === 0) next();
    });
  });
}

function lookupNoun(next){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.wordpos.wordpos.prototype.lookupAdjective" id="apidoc.element.wordpos.wordpos.prototype.lookupAdjective">
        function <span class="apidocSignatureSpan">wordpos.wordpos.prototype.</span>lookupAdjective
        <span class="apidocSignatureSpan">(word, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lookupAdjective = function (word, callback) {
  var profile = this.options.profile,
    start = profile &amp;&amp; new Date(),
    files = this.getFilesFor(pos),
    args = [];

  word = normalize(word);

  // lookup index
  return files.index.lookup(word)
    .then(function(result) {
      if (result) {
        // lookup data
        return files.data.lookup(result.synsetOffset).then(done);
      } else {
        // not found in index
        return done([]);
      }
    })
    .catch(done);

  function done(results) {
    if (results instanceof Error) {
      args.push([], word);
    } else {
      args.push(results, word);
    }
    //console.log(3333, args)
    profile &amp;&amp; args.push(new Date() - start);
    nextTick(callback, args);
    return results;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
#### lookupAdverb(word, callback)

Get complete definition object for `word`.  The lookupX() variants can be faster if you already know the POS of the word.  Signature
 of the callback is `callback(result, word)` where `result` is an *array* of lookup object(s).

Example:

```js
wordpos.<span class="apidocCodeKeywordSpan">lookupAdjective</span>('awesome', console.log);
// output:
[ { synsetOffset: 1285602,
lexFilenum: 0,
lexName: 'adj.all',
pos: 's',
wCnt: 5,
lemma: 'amazing',
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.wordpos.wordpos.prototype.lookupAdverb" id="apidoc.element.wordpos.wordpos.prototype.lookupAdverb">
        function <span class="apidocSignatureSpan">wordpos.wordpos.prototype.</span>lookupAdverb
        <span class="apidocSignatureSpan">(word, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lookupAdverb = function (word, callback) {
  var profile = this.options.profile,
    start = profile &amp;&amp; new Date(),
    files = this.getFilesFor(pos),
    args = [];

  word = normalize(word);

  // lookup index
  return files.index.lookup(word)
    .then(function(result) {
      if (result) {
        // lookup data
        return files.data.lookup(result.synsetOffset).then(done);
      } else {
        // not found in index
        return done([]);
      }
    })
    .catch(done);

  function done(results) {
    if (results instanceof Error) {
      args.push([], word);
    } else {
      args.push(results, word);
    }
    //console.log(3333, args)
    profile &amp;&amp; args.push(new Date() - start);
    nextTick(callback, args);
    return results;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.wordpos.wordpos.prototype.lookupNoun" id="apidoc.element.wordpos.wordpos.prototype.lookupNoun">
        function <span class="apidocSignatureSpan">wordpos.wordpos.prototype.</span>lookupNoun
        <span class="apidocSignatureSpan">(word, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lookupNoun = function (word, callback) {
  var profile = this.options.profile,
    start = profile &amp;&amp; new Date(),
    files = this.getFilesFor(pos),
    args = [];

  word = normalize(word);

  // lookup index
  return files.index.lookup(word)
    .then(function(result) {
      if (result) {
        // lookup data
        return files.data.lookup(result.synsetOffset).then(done);
      } else {
        // not found in index
        return done([]);
      }
    })
    .catch(done);

  function done(results) {
    if (results instanceof Error) {
      args.push([], word);
    } else {
      args.push(results, word);
    }
    //console.log(3333, args)
    profile &amp;&amp; args.push(new Date() - start);
    nextTick(callback, args);
    return results;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  });
}

function lookupNoun(next){
  var count = nwords;
  found = 0;
  parsedText.forEach(function(word) {
    wordpos.<span class="apidocCodeKeywordSpan">lookupNoun</span>(word, function (res) {
      res.length &amp;&amp; ++found;
      if (--count === 0) next();
    });
  });
}

suite.section('--512 words--', function(next){
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.wordpos.wordpos.prototype.lookupVerb" id="apidoc.element.wordpos.wordpos.prototype.lookupVerb">
        function <span class="apidocSignatureSpan">wordpos.wordpos.prototype.</span>lookupVerb
        <span class="apidocSignatureSpan">(word, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lookupVerb = function (word, callback) {
  var profile = this.options.profile,
    start = profile &amp;&amp; new Date(),
    files = this.getFilesFor(pos),
    args = [];

  word = normalize(word);

  // lookup index
  return files.index.lookup(word)
    .then(function(result) {
      if (result) {
        // lookup data
        return files.data.lookup(result.synsetOffset).then(done);
      } else {
        // not found in index
        return done([]);
      }
    })
    .catch(done);

  function done(results) {
    if (results instanceof Error) {
      args.push([], word);
    } else {
      args.push(results, word);
    }
    //console.log(3333, args)
    profile &amp;&amp; args.push(new Date() - start);
    nextTick(callback, args);
    return results;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.wordpos.wordpos.prototype.parse" id="apidoc.element.wordpos.wordpos.prototype.parse">
        function <span class="apidocSignatureSpan">wordpos.wordpos.prototype.</span>parse
        <span class="apidocSignatureSpan">(text)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function prepText(text) {
  if (_.isArray(text)) return text;
  var deduped = _.uniq(tokenizer(text));
  if (!this.options.stopwords) return deduped;
  return _.reject(deduped, _.bind(isStopword, null,
    _.isString(this.options.stopwords) ? this.options.stopwords : stopwordsStr
  ));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return k + ':' + res[k].length
});
}


var
text = fs.readFileSync('text-512.txt', 'utf8'),
parsedText = wordpos.<span class="apidocCodeKeywordSpan">parse</span>(text),
nwords = parsedText.length,
pos;


function getPOS(next){
wordpos.getPOS(text, function(res){
  pos = res;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.wordpos.wordpos.prototype.seek" id="apidoc.element.wordpos.wordpos.prototype.seek">
        function <span class="apidocSignatureSpan">wordpos.wordpos.prototype.</span>seek
        <span class="apidocSignatureSpan">(offset, pos, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">seek = function (offset, pos, callback){
  offset = Number(offset);
  if (_.isNaN(offset) || offset &lt;= 0) return error('offset must be valid positive number.');

  var data = this.getFilesFor(pos).data;
  if (!data) return error('Incorrect POS - 2nd argument must be a, r, n or v.');

  return data.lookup(offset, callback);

  function error(msg) {
    var err = new Error(msg);
    callback &amp;&amp; callback(err, {});
    return Promise.reject(err);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...


#### seek(offset, pos, callback)
Version 1.1 introduces the seek method to lookup a record directly from the synsetOffset for a given POS.  Unlike other methods,
callback (if provided) receives `(err, result)` arguments.

Examples:
```js
wordpos.<span class="apidocCodeKeywordSpan">seek</span>(1285602, 'a').then(console.log)
// same result as wordpos.lookupAdjective('awesome', console.log);
```

#### rand(options, callback)
#### randNoun(options, callback)
#### randVerb(options, callback)
#### randAdjective(options, callback)
...</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>